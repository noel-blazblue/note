## setState 批量更新

`setState` 不会触发多次渲染，并且 `state` 的值也不是实时的，这样的做法能够减少不必要的性能消耗。

```
isBatchingUpdates = true
try {
    handleClick()
} finally {
    isBatchingUpdates = false
    // 然后去更新
}
```

当我们在 `handleClick` 内部执行 `setState` 时，更新状态的这部分代码首先会被丢进一个队列中等待后续的使用。然后继续处理更新的逻辑

组件更新流程其实是有两个截然不同的分支的。一种就是触发更新以后一次完成全部的组件更新流程；另一种是触发更新以后分时间片段完成所有的组件更新，用户体验更好，这种方式被称之为任务调度。



## Fiber 

React 的组件更新过程简而言之就是在持续调用函数的一个过程，这样的一个过程会形成一个虚拟的调用栈。假如我们控制这个调用栈的执行

把整个更新任务拆解开来，尽可能地将更新任务放到浏览器空闲的时候去执行，那么就能解决以上的问题。

这些功能主要是通过两个核心的技术来实现的：

- 新的数据结构 fiber
- 调度器



### fiber

fiber是个链表结构，记录了很多上下文的信息，其中就有对节点的操作，形成一个工作单元。执行更新任务就是在反复寻找工作单元并运行它们，这样的方式就实现了拆分任务的功能。

依托于fiber，就可以控制调用栈的内容，可以随时去执行它们，也可以随时中断它们。



拆分成工作单元的目的就是为了让我们能控制 stack frame（调用栈中的内容），可以随时随地去执行它们。由此使得我们在每运行一个工作单元后都可以按情况继续执行或者中断工作（中断的决定权在于调度算法）。

![img](https://user-gold-cdn.xitu.io/2019/7/21/16c14ea212e58566?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

```
{
  ...
  // 浏览器环境下指 DOM 节点
  stateNode: any,
    
  // 形成列表结构
  return: Fiber | null,
  child: Fiber | null,
  sibling: Fiber | null,

  // 更新相关
  pendingProps: any,  // 新的 props
  memoizedProps: any,  // 旧的 props
  // 存储 setState 中的第一个参数
  updateQueue: UpdateQueue<any> | null, 
  memoizedState: any, // 旧的 state
    
  // 调度相关
  expirationTime: ExpirationTime,  // 任务过期时间
    
  // 大部分情况下每个 fiber 都有一个替身 fiber
  // 在更新过程中，所有的操作都会在替身上完成，当渲染完成后，
  // 替身会代替本身
  alternate: Fiber | null,

  // 先简单认为是更新 DOM 相关的内容
  effectTag: SideEffectTag, // 指这个节点需要进行的 DOM 操作
  // 以下三个属性也会形成一个链表
  nextEffect: Fiber | null, // 下一个需要进行 DOM 操作的节点
  firstEffect: Fiber | null, // 第一个需要进行 DOM 操作的节点
  lastEffect: Fiber | null, // 最后一个需要进行 DOM 操作的节点，同时也可用于恢复任务
  ....
}
```

我们可以认为 fiber 就是一个工作单元的数据结构表现，当然它同样也是调用栈中的一个重要组成部分。



### 调度器

每次有新的更新任务发生的时候，调度器都会按照策略给这些任务分配一个优先级，通过这个优先级我们可以获取一个该更新任务必须执行的截止时间，优先级越高那么截止时间就越近。

这个截止时间是用来判断该任务是否已经过期，如果过期的话就会马上执行该任务。



比如说动画的更新优先级会高点，离屏元素的更新优先级会低点。

然后调度器通过实现 `requestIdleCallback` 函数来做到在浏览器空闲的时候去执行这些更新任务。

其原理就是通过定时器的方式，来获取每一帧的结束时间。得到每一帧的结束时间以后我们就能判断当下距离结束时间的一个差值。

如果还未到结束时间，那么也就意味着我可以继续执行更新任务；如果已经过了结束时间，那么就意味着当前帧已经没有时间给我执行任务了，必须把执行权交还给浏览器，也就是打断任务的执行。



- 当交互事件调用 `setState` 后，会触发批量更新，在整个交互事件回调执行完之前 `state` 都不会发生变更。

- 回调执行完毕后，开始更新任务，并触发调度。调度器会给这些更新任务一一设置优先级，并且在浏览器空闲的时候去执行他们，当然任务过期除外（会立刻触发更新，不再等待）。

- 如果在执行更新任务的时候，有新的任务进来，会判断两个任务的优先级高低。假如新任务优先级高，那么打断旧的任务，重新开始，否则继续执行任务。

