## 浏览器







### 缓存

#### HTTP缓存

1. 减少了冗余的数据传输
2. 缓解了服务器的压力
3. 加快了客户端加载网页的速度 

![img](https://upload-images.jianshu.io/upload_images/4845448-39248bf4a3b45c3e?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp) 

![http-cdn-http-process](https://user-gold-cdn.xitu.io/2018/11/8/166f2735c584653e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 



第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数 。

第二次请求时，浏览器判断这些请求参数 



1.看看是否命中强缓存，如果命中，就直接200，使用缓存了。

2.如果没有命中强缓存，就把请求参数加到请求头，发到服务器检查是否命中协商缓存。

3.如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存。

4.否则，返回最新的资源。

5.强缓存 

- Expires
- Cache-control

6.协商缓存 

- Last-Modified/If-Modified-Since
- Etag/If-None-Match

 

#####  **强制缓存** 

![img](https://upload-images.jianshu.io/upload_images/4845448-217723260f75ed90) 

强制缓存在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期） ，那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。 

 



##### **协商缓存** 

![img](https://upload-images.jianshu.io/upload_images/4845448-a22cef109d00aa79?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp) 

那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。

如果服务器端的资源没有修改，那么就会返回304状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。

如果数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。

- ETag/If-Not-Match 
  - 第一次请求，响应头 ETag 返回一个hash值 
  - 第二次请求，请求头 If-Not-Match 带上 Etag 的值
- Last-Modified/If-Modified-Since  
  - 第一次请求，响应头 Last-Modified 返回 GMT 格式的最后修改时间 
  - 第二次请求，请求头 If-Modified-Since  带上 Last-Modified 的值





##### 私有缓存与共享缓存

**私有缓存（浏览器级缓存）**
私有缓存只能用于单独的用户：Cache-Control: Private

**共享缓存（代理级缓存）**
共享缓存可以被多个用户使用: Cache-Control: Public

 

####  浏览器缓存

  浏览器缓存有：cookie、sessionStorage、localStorage 

![img](https://upload-images.jianshu.io/upload_images/4845448-f0cd7f084e812844?imageMogr2/auto-orient/strip%7CimageView2/2/w/674/format/webp) 











### 浏览器架构





### 重绘与回流

当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。 

- **重绘(repaint)**: 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 **损耗较少**
- **回流(reflow)**: 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:
  - 页面初次渲染
  - 浏览器窗口大小改变
  - 元素尺寸、位置、内容发生改变
  - 元素字体大小变化
  - 添加或者删除可见的 dom 元素
  - 激活 CSS 伪类（例如：:hover）
    - clientWidth、clientHeight、clientTop、clientLeft
    - offsetWidth、offsetHeight、offsetTop、offsetLeft
    - scrollWidth、scrollHeight、scrollTop、scrollLeft
    - getComputedStyle()
    - getBoundingClientRect()
    - scrollTo()

 **回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。** 



#### 例子:

- css
  - 避免使用`table`布局
  - 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上
- javascript
  - 避免频繁操作样式，可汇总后统一 **一次修改**
  - 尽量使用`class`进行样式修改
  - 减少`dom`的增删次数，可使用 **字符串** 或者 `documentFragment` 一次性插入
  - 极限优化时，修改样式可将其`display: none`后修改
  - 避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 **变量存住**



###  Web Worker

现代浏览器为`JavaScript`创造的 **多线程环境**。可以将部分任务分配到`worker`线程并行运行，等到 Worker 线程完成计算任务，再把结果返回给主线程。 

这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。 



两个线程可 **独立运行，互不干扰**，可通过自带的 **消息机制** 相互通信。

**基本用法:**

```
// 创建 worker
const worker = new Worker('work.js');

// 向主进程推送消息
worker.postMessage('Hello World');

// 监听主进程来的消息
worker.onmessage = function (event) {
  console.log('Received message ' + event.data);
}
```



#### 限制:

（1）**同源限制**

分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。

（2）**DOM 限制**

Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用`document`、`window`、`parent`这些对象。但是，Worker 线程可以`navigator`对象和`location`对象。

（3）**通信联系**

Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。

（4）**脚本限制**

Worker 线程不能执行`alert()`方法和`confirm()`方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。

（5）**文件限制**

Worker 线程无法读取本地文件，即不能打开本机的文件系统（`file://`），它所加载的，必须来自网络。

 

###  内存泄漏

- 意外的**全局变量**: 无法被回收
- **定时器**: 未被正确关闭，导致所引用的外部变量无法被释放
- **事件监听**: 没有正确销毁 (低版本浏览器可能出现)
- **闭包**: 会导致父级中的变量无法被释放
- **dom 引用**: dom 元素被删除时，内存中的引用未被正确清空

可用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点。

 

对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 不再用到的内存，如果没有及时释放，就叫做内存泄漏（memory leak）。 

1. 打开开发者工具，选择 Timeline 面板
2. 在顶部的`Capture`字段里面勾选 Memory



**解决：**

[WeakSet](http://es6.ruanyifeng.com/#docs/set-map#WeakSet) 和 [WeakMap](http://es6.ruanyifeng.com/#docs/set-map#WeakMap)。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个"Weak"，表示这是弱引用。 



### 垃圾回收机制

定义和用法：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。

原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。

 

**标记清除：**

定义和用法：当变量进入环境时，将变量标记"进入环境"，当变量离开环境时，标记为："离开环境"。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。

到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。

**引用计数：**

定义和用法：引用计数是跟踪记录每个值被引用的次数。

基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。

**内存管理：**

IE6的垃圾回收是根据内存分配量运行的，当环境中的变量，对象，字符串达到一定数量时触发垃圾回收。垃圾回收器一直处于工作状态，严重影响浏览器性能。 

IE7中，垃圾回收器会根据内存分配量与程序占用内存的比例进行动态调整，开始回收工作。 

 



### 页面生命周期

HTML 页面的生命周期有三个重要事件：

- `DOMContentLoaded` —— 浏览器加载 HTML，并构建 DOM 树，但像 `<img>` 和样式这样的资源可能还没有加载。
- `load` —— 浏览器加载所有资源（图像，样式等）。
- `beforeunload/unload` —— 当用户离开页面时。



每个事件都是有用的：

- `DOMContentLoaded` 事件 —— DOM 已经准备好，因此处理器可以查找 DOM 节点，并初始化接口。
- `load` 事件 —— 额外资源被加载后，我们可以获取图像大小（如果在 HTML/CSS 中没有指定）等。
- `beforeunload/unload` 事件 —— 用户即将离开：我们可以检查用户是否保存了修改，并在询问他是否真的要离开。



#### 页面渲染流程

![img](https://tuchuang-zc.oss-cn-shenzhen.aliyuncs.com/site-pictures/critical-rendering-path.png) 

1. 构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree）；
2. 构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树；
3. 执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件）；
4. 构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree), 渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。

1. 布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置；
2. 绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成；



#### 阻塞渲染







##  服务器

 

###   get / post

- get: 缓存、请求长度受限、会被历史保存记录
  - 无副作用(不修改资源)，幂等(请求次数与资源无关)的场景
- post: 安全、大数据、更多编码类型

![img](https://user-gold-cdn.xitu.io/2019/2/14/168e9d9050b9d08a?imageslim) 



### SESSION

SESSION是服务端的一种会话状态，用于存储有关用户会话的信息。

Session 的工作机制是：为每个访问者创建一个唯一的 id (UID)，并基于这个 UID 来存储变量。UID 存储在 cookie 中，亦或通过 URL 进行传导 



### 安全



- XSS攻击: 注入恶意代码
  - cookie 设置 httpOnly
  - 转义页面上的输入内容和输出内容
- CSRF: 跨站请求伪造，防护:
  - get 不修改数据
  - 不被第三方网站访问到用户的 cookie
  - 设置白名单，不被第三方网站请求
  - 请求校验





####  DDOS 

 DDOS 攻击，它在短时间内发起大量请求，耗尽服务器的资源，无法响应正常的访问，造成网站实质下线。 

防范：

1.防范 DDOS 的第一步，就是你要有一个备份网站，或者最低限度有一个临时主页。生产服务器万一下线了，可以立刻切换到备份网站，不至于毫无办法。 

2.如果恶意请求有特征，对付起来很简单：直接拦截它就行了。 IP 地址和 User Agent 字段。比如，恶意请求都是从某个 IP 段发出的，那么把这个 IP 段封掉就行了。或者，它们的 User Agent 字段有特征（包含某个特定的词语），那就把带有这个词语的请求拦截。 

3.带宽扩容，CDN网站的静态内容分发到多个服务器，用户就近访问，提高速度。 

