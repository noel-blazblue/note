## 进程

> `进程`之间相互独立，任一时刻，CPU总是运行一个`进程`，其他`进程`处于非运行状态。 CPU使用时间片轮转进度算法来实现同时运行多个`进程`。



对于计算机来说，每一个应用程序都是一个`进程`， 而每一个应用程序都会分别有很多的功能模块，这些功能模块实际上是通过`子进程`来实现的。 对于这种`子进程`的扩展方式，我们可以称这个应用程序是`多进程`的。

![æµè§å¨æ¯å¤è¿ç¨ç](https://user-gold-cdn.xitu.io/2019/8/21/16cb1f0a851c86b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 浏览器是多进程的
- 每一个Tab页，就是一个独立的进程



## 线程

一个`进程`可以包括多个`线程`，多个`线程`共享`进程`资源。



- `进程`是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
- `线程`是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
- 不同`进程`之间也可以通信，不过代价较大
- `单线程`与`多线程`，都是指在一个`进程`内的单和多



## 浏览器进程

- **主进程** 
  - 协调控制其他子进程（创建、销毁）
  - 浏览器界面显示，用户交互，前进、后退、收藏
  - 将渲染进程得到的内存中的Bitmap，绘制到用户界面上
  - 处理不可见操作，网络请求，文件访问等
- **第三方插件进程** 
  - 每种类型的插件对应一个进程，仅当使用该插件时才创建
- **GPU进程** 
  - 用于3D绘制等
- **渲染进程**：就是我们说的浏览器内核
  - 负责页面渲染，脚本执行，事件处理等
  - 每个tab页一个渲染进程



## 浏览器内核（渲染进程）

- **GUI渲染线程**
  - 负责渲染页面，布局和绘制
  - 页面需要重绘和回流时，该线程就会执行
  - 与js引擎线程互斥，防止渲染结果不可预期
- **JS引擎线程**
  - 负责处理解析和执行javascript脚本程序
  - 只有一个JS引擎线程（单线程）
  - 与GUI渲染线程互斥，防止渲染结果不可预期
- **事件触发线程**
  - 用来控制事件循环（鼠标点击、setTimeout、ajax等）
  - 当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中
- **定时触发器线程**
  - setInterval与setTimeout所在的线程
  - 定时任务并不是由JS引擎计时的，是由定时触发线程来计时的
  - 计时完毕后，通知事件触发线程
- **异步http请求线程**
  - 浏览器有一个单独的线程用于处理AJAX请求
  - 当请求完成时，若有回调函数，通知事件触发线程



### javascript 单线程

> 第一，是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。
>
> 第二，如果同时操作 DOM ，会导致 DOM 渲染的结果不可预期。



为了防止渲染出现不可预期的结果，浏览器设定 `GUI渲染线程`和`JS引擎线程`为互斥关系， 当`JS引擎线程`执行时`GUI渲染线程`会被挂起，GUI更新则会被保存在一个队列中等待`JS引擎线程`空闲时立即被执行。



## Event Loop



![img](https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7433f29c46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

当代码执行到`setTimeout/setInterval`时，实际上是`JS引擎线程`通知`定时触发器线程`，间隔一个时间后，会触发一个回调事件， 而`定时触发器线程`在接收到这个消息后，会在等待的时间后，将回调事件放入到由`事件触发线程`所管理的`事件队列`中。

当代码执行到`XHR/fetch`时，实际上是`JS引擎线程`通知`异步http请求线程`，发送一个网络请求，并制定请求完成后的回调事件， 而`异步http请求线程`在接收到这个消息后，会在请求成功后，将回调事件放入到由`事件触发线程`所管理的`事件队列`中。


当我们的同步任务执行完，`JS引擎线程`会询问`事件触发线程`，在`事件队列`中是否有待执行的回调函数，如果有就会加入到执行栈中交给`JS引擎线程`执行

![img](https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7433f29c46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- JS引擎线程只执行执行栈中的事件
- 执行栈中的代码执行完毕，就会读取事件队列中的事件
- 事件队列中的回调事件，是由各自线程插入到事件队列中的
- 如此循环



### 宏任务

浏览器为了能够使`宏任务`和`DOM任务`有序的进行，会在一个`宏任务`执行结果后，在下一个`宏任务`执行前，`GUI渲染线程`开始工作，对页面进行渲染。

主代码块，setTimeout，setInterval等，都属于宏任务



### 微任务

微任务可以理解成在当前`宏任务`执行后立即执行的任务。也就是说，当`宏任务`执行完，会在渲染前，将执行期间所产生的所有`微任务`都执行完。



### 总结

- 执行一个`宏任务`（栈中没有就从`事件队列`中获取）

- 执行过程中如果遇到`微任务`，就将它添加到`微任务`的任务队列中

- `宏任务`执行完毕后，立即执行当前`微任务队列`中的所有`微任务`（依次执行）

- 当前`宏任务`执行完毕，开始检查渲染，然后`GUI线程`接管渲染

- 渲染完毕后，`JS线程`继续接管，开始下一个`宏任务`（从事件队列中获取）
  ![img](https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7bb4bd9fd2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

