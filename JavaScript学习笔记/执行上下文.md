## JS编译原理

![img](https://user-gold-cdn.xitu.io/2019/3/16/169826acb0356502?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 

### 词法分析

这些代码块被称为词法单元(token) ，这些词法单元组成了词法单元流数组 

把代码分解为一个个词法单元，这些词法单元组成了词法单元流数组

```
var sum = 30;
// 词法分析后的结果
[
  "var" : "keyword",
  "sum" : "identifier",
  "="   : "assignment",
  "30"  : "integer",
  ";"   : "eos" (end of statement)
]
```



### 语法分析

把词法单元流数组转换成一个由元素逐级嵌套所组成的代表程序语法结构的树，这个树被称为“抽象语法树” (`Abstract Syntax Tree`, 简称`AST`)。 



### 代码生成

将抽象语法树（`AST`）转换为一组机器指令，也就是可执行代码，简单说，就是用来创建一个变量a，并将3这个值储存在a中。 



- `JavaScript` 大部分情况下编译发生在代码执行前的几微秒(甚至更短!)的时间内
- `JavaScript` 引擎用尽了各种办法(比如 `JIT`，可以延 迟编译甚至实施重编译)来保证性能最佳



## 执行上下文

执行上下文可以简单理解为一个对象:

- 它包含三个部分:
  - 变量对象(VO)
  - 作用域链(词法作用域)
  - `this`指向
- 它的类型:
  - 全局执行上下文
  - 函数执行上下文
  - `eval`执行上下文
- 代码执行过程:
  - 创建 **全局上下文** (global EC)
  - 全局执行上下文 (caller) 逐行 **自上而下** 执行。遇到函数时，**函数执行上下文** (callee) 被`push`到执行栈顶层
  - 函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起
  - 函数执行完后，callee 被`pop`移除出执行栈，控制权交还全局上下文 (caller)，继续执行

 

**变量对象(VO)**，执行上下文的容器对象，储存变量和函数声明。

**Activation object**： 函数上下文中 VO 叫做 AO，除变量与函数的声明定义外，还有形参及arguments 对象  



JavaScript 代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。 

 

##  作用域链

![img](https://user-gold-cdn.xitu.io/2019/3/16/16982853f08e1db5?imageslim) 

 

### AO

**变量对象(VO)**，执行上下文的容器对象，储存变量和函数声明。

**Activation object**： 函数上下文中 VO 叫做 AO，除变量与函数的声明定义外，还有形参及arguments 对象  



函数运行的瞬间，创建一个AO (Active Object 活动对象)运行载体。 属性：

- 形参
- 实参
- 变量声明
- 函数声明



函数声明特点：AO上如果有与函数名同名的属性,则会被此函数覆盖。

变量声明特点：AO上如果有同名属性，不做任何事。



### `LHS`和`RHS`查询

LHS ： 变量赋值或写入内存。想象为将文本文件保存到硬盘中。 

RHS ： 变量查找或从内存中读取。想象为从硬盘打开文本文件。



特点：

- 都会在所有作用域中查询
- 严格模式下，找不到所需的变量时，引擎都会抛出`ReferenceError`异常。
- 非严格模式下，`LHR`稍微比较特殊: 会自动创建一个全局变量
- 查询成功时，如果对变量的值进行不合理的操作，比如：对一个非函数类型的值进行函数调用，引擎会抛出`TypeError`异常



