## 单线程

为了保证交互效果的一致性，JS同一个时间只能做一件事。 



于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 



## 执行栈

（1）所有同步任务都在主线程上执行，形成一个[执行栈](http://www.ruanyifeng.com/blog/2013/11/stack.html)（execution context stack）。

（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

（4）主线程不断重复上面的第三步。



## 任务队列

如果碰到异步任务，就会将其挂起，然后继续去执行执行栈中的其他同步任务，等到异步任务有了结果，就把它的回调函数放到任务队列中，等到执行栈清空，主线程空闲，就去读取任务队列中的任务，把它放到执行栈的顶部执行。



"任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，"任务队列"上第一位的事件就自动进入主线程。但是，"定时器"功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。 



## 宏任务与微任务

不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。 

以下事件属于宏任务：

- `setInterval()`
- `setTimeout()`
- script

以下事件属于微任务

- `new Promise()`

- ajax

- `new MutaionObserver()`

  



在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈...如此反复，进入循环。

**当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行**。



## 事件循环

JS会优先执行执行栈中的同步任务，如果遇到了异步任务，就会把他挂起，继续执行其他的任务。当一个异步任务返回结果后，就把他放入任务队列中，等到清空执行栈，主线程闲置后，就会取出任务队列中排在第一位的事件，并把这个事件对应的回调放入执行栈中执行他的同步代码，如此反复。