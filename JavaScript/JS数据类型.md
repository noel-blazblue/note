> 参考链接：http://www.cnblogs.com/onepixel/p/5140944.html



- 基本类型：String、Number、Boolean、Symbol、Undefined、Null 
- 引用类型：Object



## **一、String 类型**

String 类型用于表示由零或多个 16 位 Unicode 字符组成的字符序列，即字符串 。 



#### 1.基本包装类型

在 JavaScript 中，字符串是基本数据类型，本身不存任何操作方法 。为了方便的对字符串进行操作，ECMAScript 提供了一个基本包装类型：String 对象 。它是一种特殊的引用类型，JS引擎每当读取一个字符串的时候，就会在内部创建一个对应的 String 对象，该对象提供了很多操作字符的方法 



```
var name = 'JavaScript';
var value = name.substr(2,1);
```



当字符串调用方法时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，引擎内部会自动完成下列处理： 

- 创建 String 类型的一个实例
- 在实例上调用指定的方法
- 销毁这个实例



## 二、Number 类型

#### 1.存储结构

JavaScript 中的数字类型只有 Number 一种，Number 类型采用 IEEE754 标准中的 “**双精度浮点数**” 来表示一个数字，不区分整数和浮点数 。

在 IEEE754 中，双精度浮点数采用 **64 位存储**，即 8 个字节表示一个浮点数 。 



####  2.数值范围

JavaScript 中能表示的最大值是 1.7976931348623157 × 10308，最小值为 5 × 10-324 。

这两个边界值可以分别通过访问 Number 对象的 MAX_VALUE 属性和 MIN_VALUE 属性来获取：

如果数字超过最大值或最小值，JavaScript 将返回一个不正确的值，这称为 **“正向溢出(overflow)”** 或 **“负向溢出(underflow)”** 。 



#### 3.数值精度

JavaScript 能表示并进行精确算术运算的整数范围为：[-253-1，253-1]，即从最小值 -9007199254740991 到最大值 9007199254740991 之间的范围 。 

超过这个范围的整数，JavaScript 依旧可以进行运算，但却不保证运算结果的精度。 

计算机中的数字都是以二进制存储的，如果要计算 0.1 + 0.2 的结果，计算机会先把 0.1 和 0.2 分别转化成二进制，然后相加，最后再把相加得到的结果转为十进制 。

但有一些浮点数在转化为二进制时，会出现无限循环 。



#### 4.数值转换

有 3 个函数可以把非数值转换为数值，分别如下： 

```
Number(value)
parseInt(string [, radix])
parseFloat(string)
```

Number() 可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。 

对于字符串而言，Number() 只能对字符串进行整体转换，而 parseInt() 和 parseFloat() 可以对字符串进行部分转换，即只转换第一个无效字符之前的字符。 



对于不同数据类型的转换，Number() 的处理也不尽相同，其转换规则如下:

【1】如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。 

【2】如果是数字值，只是简单的传入和返回。

【3】如果是 null 值，返回 0。

【4】如果是 undefined，返回 NaN。

【5】如果是字符串，遵循下列规则：

- 如果字符串中只包含数字(包括前面带正号或负号的情况)，则将其转换为十进制数值; 
- 如果字符串中包含有效的浮点格式，则将其转换为对应的浮点数值; 
- 如果字符串中包含有效的十六进制格式，则将其转换为相同大小的十进制整数值; 
- 如果字符串是空的(不包含任何字符)，则将其转换为 0; 
- 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。

【6】如果是对象，则调用对象的 valueOf() 方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString() 方法，然后再次依照前面的规则转换返回的字符串值。



## 三、Boolean 类型







## 类型转换

![img](https://user-gold-cdn.xitu.io/2018/11/15/16716dec14421e47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 

对象在转换类型的时候，会调用内置的 `[[ToPrimitive]]` 函数，对于该函数来说，算法逻辑一般来说如下： 

- 如果已经是原始类型了，那就不需要转换了
- 调用 `x.valueOf()`，如果转换为基础类型，就返回转换的值
- 调用 `x.toString()`，如果转换为基础类型，就返回转换的值
- 如果都没有返回原始类型，就会报错



### 四则运算符

#### 加法运算符

- 运算中其中一方为字符串，那么就会把另一方也转换为字符串
- 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串

```
1 + '1' // '11'
true + true // 2
4 + [1,2,3] // "41,2,3"
```



#### 其他

对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字 

```
4 * '3' // 12
4 * [] // 0
4 * [1, 2] // NaN
```



### 比较运算符

1. 如果是对象，就通过 `toPrimitive` 转换对象
2. 如果是字符串，就通过 `unicode` 字符索引来比较

```
let a = {
  valueOf() {
    return 0
  },
  toString() {
    return '1'
  }
}
a > -1 // true
```



### ==  ===

对于 `==` 来说，如果对比双方的类型**不一样**的话，就会进行**类型转换** 

1. 首先会判断两者类型是否**相同**。相同的话就是比大小了
2. 类型不相同的话，那么就会进行类型转换
3. 会先判断是否在对比 `null` 和 `undefined`，是的话就会返回 `true`
4. 判断两者类型是否为 `string` 和 `number`，是的话就会将字符串转换为 `number`
5. 判断其中一方是否为 `boolean`，是的话就会把 `boolean` 转为 `number` 再进行判断 
6. 判断其中一方是否为 `object` 且另一方为 `string`、`number` 或者 `symbol`，是的话就会把 `object` 转为原始类型再进行判断 

```
1 == '1'
      ↓
1 ==  1

'1' == true
        ↓
'1' ==  1
        ↓
 1  ==  1
 
 '1' == { name: 'yck' }
        ↓
'1' == '[object Object]'
```

![img](https://user-gold-cdn.xitu.io/2018/12/19/167c4a2627fe55f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 



