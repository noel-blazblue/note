### 实现一个并发量为5个的请求方法
```js
function request(list = [], limit, asyncHandle) {
  return new Promise((resolve, reject) => {
    let index = 0
    let finished = 0
    let result = []
    let recursion = () => {
      let tmpIndex = index++
      asyncHandle(list[tmpIndex])
        .then(data => result[tmpIndex] = data)
        .catch(err => result[tmpIndex] = err)
        .finish(() => {
          if (index < list.length) {
            recursion()
          } else if (++finished >= list.length) {
            resolve(result)
          }
        })
    }
    while (limit--) {
      recursion()
    }
  })
}
```

### 函数异步增加
```js
function fn1(a, cd) {
  setTimeout(() => cd(a + 1), 0)
}
function fn2(a, cd) {
  setTimeout(() => cd(a + 1), 0)
}
function fn3(a, cd) {
  setTimeout(() => cd(a + 1), 0)
}

async function run(initialValue, fnArr = [], callback) {
  let acc = initialValue
  for (let fn of fnArr) {
    acc = await new Promise(resolve => fn(acc, resolve))
  }
  callback(acc)
}

function run(initialValue, fnArr = [], callback) {
  fnArr.reduce(
    (acc, cur) => acc.then(
      value => new Promise(
        resolve => cur(value, resolve)
      )
    ), 
    Promise.resolve(initialValue)
  )
    .then(res => callback(res))
}

run(1, [fn1, fn2, fn3], console.log)
```