## JS编译原理 

![img](https://user-gold-cdn.xitu.io/2019/9/22/16d54b68820e9ee9?imageslim)

![img](https://user-gold-cdn.xitu.io/2019/9/22/16d54cb557ec70e1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 词法分析

这些代码块被称为词法单元(token) ，这些词法单元组成了词法单元流数组 

把代码分解为一个个词法单元，这些词法单元组成了词法单元流数组

```
var sum = 30;
// 词法分析后的结果
[
  "var" : "keyword",
  "sum" : "identifier",
  "="   : "assignment",
  "30"  : "integer",
  ";"   : "eos" (end of statement)
]
```



### 语法分析

把词法单元流数组转换成一个由元素逐级嵌套所组成的代表程序语法结构的树，这个树被称为“抽象语法树” (`Abstract Syntax Tree`, 简称`AST`)。 



### 代码生成

将抽象语法树（`AST`）转换为一组机器指令，也就是可执行代码，简单说，就是用来创建一个变量a，并将3这个值储存在a中。 



- `JavaScript` 大部分情况下编译发生在代码执行前的几微秒(甚至更短!)的时间内
- `JavaScript` 引擎用尽了各种办法(比如 `JIT`，可以延 迟编译甚至实施重编译)来保证性能最佳



JavaScript引擎主要组成部分：

- 编译器：负责语法分析和代码生成。
- 解析器：负责接收字码节和解析执行字码节。
- JIT工具：将字码节或者抽象语法树转换为本地代码（可执行代码）。
- 垃圾回收器和分析工具（Profiler）：负责垃圾回收和收集引擎中的信息，帮助改善引擎的性能和功效。

JavaScript本质上是一种解释型语言，与编译型语言不同的是它需要一遍执行一边解析，而编译型语言在执行时已经完成编译，可直接执行，有更快的执行速度。





## 执行上下文

执行上下文可以简单理解为一个对象:

- 它包含三个部分:
  - 变量对象(VO)
  - 作用域链(词法作用域)
  - `this`指向
- 它的类型:
  - 全局执行上下文
  - 函数执行上下文
  - `eval`执行上下文
- 代码执行过程:
  - 创建 **全局上下文** (global EC)
  - 全局执行上下文 (caller) 逐行 **自上而下** 执行。遇到函数时，**函数执行上下文** (callee) 被`push`到执行栈顶层
  - 函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起
  - 函数执行完后，callee 被`pop`移除出执行栈，控制权交还全局上下文 (caller)，继续执行



JavaScript 代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。 

 

##  作用域链

![img](https://user-gold-cdn.xitu.io/2019/3/16/16982853f08e1db5?imageslim) 

 当代码在一个环境中创建时，会创建变量对象的一个作用域链（scope chain）来保证对执行环境有权访问的变量和函数。作用域第一个对象始终是当前执行代码所在环境的变量对象（VO）。如果是函数执行阶段，那么将其activation object（AO）作为作用域链第一个对象，第二个对象是上级函数的执行上下文AO，下一个对象依次类推。



### AO

**变量对象(VO)**，执行上下文的容器对象，储存变量和函数声明。

**Activation object**： 函数上下文中 VO 叫做 AO，除变量与函数的声明定义外，还有形参及arguments 对象  



函数运行的瞬间，创建一个AO (Active Object 活动对象)运行载体。 属性：

- 形参
- 实参
- 变量声明
- 函数声明



### `LHS`和`RHS`查询

LHS ： 变量赋值或写入内存。想象为将文本文件保存到硬盘中。 

RHS ： 变量查找或从内存中读取。想象为从硬盘打开文本文件。



特点：

- 都会在所有作用域中查询
- 严格模式下，找不到所需的变量时，引擎都会抛出`ReferenceError`异常。
- 非严格模式下，`LHR`稍微比较特殊: 会自动创建一个全局变量
- 查询成功时，如果对变量的值进行不合理的操作，比如：对一个非函数类型的值进行函数调用，引擎会抛出`TypeError`异常



## 函数生命周期

### 分析阶段

创建：JS解析引擎进行预解析，会将函数声明提前，同时将该函数放到全局作用域中或当前函数的上一级函数的局部作用域中。



**VO：**Variable Object（变量对象），对应的是函数创建阶段，JS解析引擎进行预解析时，所有的变量和函数的声明

- 变量 (var, 变量声明);
- 函数声明 (FunctionDeclaration, 缩写为FD);
- 函数的形参



### 执行阶段

执行：JS引擎会将当前函数的局部变量和内部函数进行声明提前，然后再执行业务代码，当函数执行完退出时，释放该函数的执行上下文，并注销该函数的局部变量。



**AO : **  AO对应的是函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，该变量共同组成了一个新的对象就是Activetion Object。

- 函数的所有局部变量
- 函数的形参及arguments 对象  
- 函数的参数集合
- 函数的this指向





## 垃圾回收机制

V8将堆分成三个部分。年轻代、年老代、和大对象。

![img](https://user-gold-cdn.xitu.io/2019/9/22/16d54d720a6156a3?imageslim)

### 新生代算法

#### Scavenge（清除）算法

1、将新生代堆内存分一为二，每一部分空间称为semispace。其中一个处于使用之中的称为from空间，另一个处于闲置称为to空间。

2、当我们分配对象时，先是在From空间中进行分配。

3、垃圾回收时，检查from空间内的存活对象，1.是否经历过清除回收，2.to空间是否已经使用了25%（保证新分配有足够的空间）。 

4、将这些存活对象复制到to空间中。非存活对象占用的空间将会被释放。

5、完成复制后，from空间与to空间角色发生对换



如何判断对象是否存活呢？作用域？是一套存储和查询变量的规则。这套规则决定了内存里对象能否访问。

特点：清除算法是典型的牺牲空间换取时间的算法，无法大规模地应用到所有回收中，却非常适合应用在新生代生命周期短的变量。



### 老生代算法

#### Mark-Sweep 标记清除

1、 标记阶段遍历堆中的所有对象，并标记活着的对象

2、 清除阶段，只清除没有被标记的对象。



最大的问题是，在进行一次标记清除之后内存空间会出现不连续的状态，而这种内存碎片会对后续的内存分配造成问题。如果分配一个大对象，那么所有的碎片空间都无法完成，就会提前触发垃圾回收，而这次全量回收是不必要的。



#### Mark-Compact 标记整理

在标记清除的基础上发展而来，在整理的过程中

1、 将活着的对象往一段移动

2、 移动完成后，直接清理掉边界外的内存



#### Incremental Marking 增量标记

垃圾回收的过程都需要将应用逻辑暂停下来。为了降低全量回收带来的停顿时间，在标记阶段，将原本一口气要完成的动作改为增量标记。垃圾回收与应用逻辑交替执行到标记阶段完成。最大停顿时间可以减少1/6左右.

