
## 1.说说你的type生成脚本吧

我从我为什么要这么做开始说吧，在实际开发业务中，许多人只是针对于前端这部分的代码去编写ts，而数据流的上游，却来自于后台的接口数据，并且这些数据并不是由我们来维护的，他的变更不可预测。因此，需要有一个功能，自动从接口文档中生成types文件，在数据流的上游就以强类型系统进行一个覆盖，然后再衔接到具体的业务代码中，这样就能保证类型系统的一个完整性。并且开发者也可以使用这些ts，减少了很多搭建类型系统的负担。

我在网上找的脚本方案中，以pont这个库最适合，他是根据接口文档的tag分类来划分命名空间，然后生成types，并且还能生成请求方法，可以省去很多的代码编写。

只不过阿里的这个库有着自己的一套严格的规范，比如需要接口直接返回数据，而不能在外层嵌套一些code信息。还有对于错误控制得不好，接口文档如果有不规范的地方，那就无法顺利执行。所以我没选择这个，而是选了另一个兼容性比较高的脚本替代。

下一步我打算私有化这个库，然后根据公司内部的一些业务规范来修改逻辑。只不过现在暂时还没有时间去研究。

同时这个事情无法完全以前端的角度去执行，毕竟接口文档是后端维护的。因此需要后端对交付出去的api有一个保证，最好也像前端这样有强类型的类型控制。

##  useRequest
`useRequest` 是一个基于数据请求，对列表页所需业务逻辑的拓展和封装，里面包含了数据处理，状态提示和错误控制，以及列表页常用逻辑如上翻页下翻页，刷新等功能，是一个纯 `model` 的 `custom-hooks`。

- 请求方法
	- 是对请求做相应的处理，用try catch来捕获。一个是更新loading状态，另一个是更新netWorkStatus状态，有success，fetching，timeout，network\_error 这些状态分类。
	
- 格式化方法
	- 基于后台的一些数据规范来进行格式化，取出列表数据。如果传入了format格式化方法，那就再对此进行执行。
	
- 翻页方法
	- 上拉下拉：用一个ref来记录最新的页码，如果当前大于或小于这个ref，那就不执行。反之更新ref页码。这样就能保证用户频繁的下拉，也只会获取下一页的。

- 防抖节流：通常用于搜索页面
	- 用一个ref来保存setTimeout的返回值，每一次执行逻辑时，判断timer是否存在
		- 存在：如果是防抖的话就清除，然后再进行一轮setTimeout，如果是防抖的话就不往下执行

- 轮询
	- 用setTimeout实现，递归调用startFetch这个请求方法。
	- startFetch里，会在开头判断timer是否存在，存在在clearTimeout。（这一步是为了手动刷新时不引起数据重复）
	- 在结尾判断轮询存在的话，就setTimeout递归调用自己，就能够形成轮询。
	- 此外还有个cancel方法，能终止轮询

- 依赖加载
	- 因为传入的请求所需的params，通常是字面量对象，所以不能直接用useEffect去监听。这个时候有两种方法去实现依赖加载
		- 一是浅比较params
		- 另一种是传入一个依赖数组，由用户自己决定以什么样的数据来引起请求变更。

## usePrevious
react hook里获取到上一个state值不太方便，不像componentDidUpdate那样。但很多时候还是有这个场景的需求的。

实现方法：
- 用两个ref，一个是pre，保存上个state，一个是cur，保存当前的state。
- 用useEffect监听，在state改变时，判断他与cur是否相等(这个判断方法默认是lodash的equel，也可以由用户自己传入)，不相等，则pre = cur， cur = state，进行更新。


##  useFocusEffect
写这个方法是因为我遇到了俩个问题：
1. 我需要在当前页面激活时，和依赖变更时都调用回调。但useDidShow只提供了页面激活时调用
2. 在我重新编译时，当前页面的useDidshow不会执行，点到另一个页面才会执行。

实现原理：
1. 定义一个useEffect，他接收传入的回调和依赖项，同时在他的依赖项中添加一个时间戳，这个时间戳由后面的useDidShow来更新，这样每次页面激活时，都能调用他。
2. 再定义一个useEffect，依赖项为空，在回调中，setFirstMount为true。这一步是为了设置一个开关，首次加载时，让useDidShow不用更新时间戳。这样就避免重复调用。
3. 定义一个useDidShow，判断firstMount为true，则更新时间戳。这样第一个useEffect就能在每次页面进入时都执行。

## 报工管理

### 业务说明
为了将坯布加工为成品，需要进行一系列工序处理，报工管理就是在这个过程中，实时的进行一个汇报。这样就能对生产过程进行一个监控，并且获得产量的统计，再从产量中计算工人的工资。

### 项目搭建
1. 拆分逻辑，把一个大的复杂的应用所需的业务逻辑拆分为一个个小的模块，也得益于 	`react-hooks` 中 `custom-hooks` 所提供的逻辑封装能力，可以化繁为简，由一个个小模块组成一个大的应用。
2. 抽象业务模型，根据业务需求梳理和分析他们的对象属性和关系，抽象为一个个业务模型，找出其中的复用点，再根据这些数据模型而去实现对应的逻辑，每个数据模型都对应着一个 `custom-hooks`，在 `custom-hooks` 中去描述数据模型的属性、行为、关联，`api` 以及 `results`， 实现一个逻辑自恰。这样就可以使得整个应用的数据流结构非常清晰透明，要增加功能以及 `debug` 都可以快速的定位，提升了代码的可读性和可维护性。
3. `model` 与 `view` 分离。这个是我个人在工作经验和对 React 设计理念的一个理解上总结出来的一个实践方式，有状态无渲染，有渲染无状态。因为在实际开发中， `model` 需要的是业务模型或者领域模型，而 `view` 需要的是视图模型，这二者之间本质上就应该解耦，各自一一个合适的设计理念去进行开发。当然

### 使用流程
1. 给工人配置他所负责的工序
2. 配置每个工序所需要的一些数据
3. 配置计件工资规则，并设置涵盖岗位，工人报工的后会自动根据自己的岗位匹配上工资的规则。
4. 进行上机配置，配置当天自己所要操作的机台，机台会关联出工序。
5. 对一张生产卡进行扫码报工，选择机台和工序，如果是首道工序需要填写产量，不然会自动计算产量。然后点击报工。

### 页面逻辑
1. 生产卡部分逻辑

	获取生产卡列表信息，如果是首道合缸的话还需要分别填写产量
	
2. 上机配置部分逻辑
	
	获取自己的上机配置，取出机台、操作员、计件规则等信息
	
3. 工艺路线部分逻辑
	
	根据生产卡列表获取工艺路线，多个工艺路线取交集，并根据当前选择的工序，取出对应的产量、状态、id等信息
	
4. 工序部分逻辑

	根据当前选择的工序，获取配置信息，决定显示哪些要提交的表单字段