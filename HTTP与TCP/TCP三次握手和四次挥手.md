参考文章：https://draveness.me/whys-the-design-https-latency/

## 名词

ACK —— 确认，使得确认号有效。 
RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。 
SYN —— 用于初如化一个连接的序列号。 
FIN —— 该报文段的发送方已经结束向对方发送数据。

### SYN
同步序列编号（**_Synchronize Sequence Numbers_**）

### ISN
初始化序列号( Initial Sequence Number)，三次握手中第一次握手的SYN包和第二次握手的SYN+ACK包中都有这个数值。

三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。

```text
ISN = M + F(localhost, localport, remotehost, remoteport)
```
M是一个计时器，每隔4毫秒加1。 F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。

### ACK
ACK (Acknowledge character）即是确认字符, 在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。

通常ACK信号有自己固定的格式,长度大小,由接收方回复给发送方。

### RST
重置链接



## 三次握手
![tcp-3-way-handshake](https://img.draveness.me/2020-02-26-15826852384249-tcp-3-way-handshake.png)
1.  客户端向服务端发送带有 `SYN` 的数据段以及客户端开始发送数据段（Segment）的初始序列号 `SEQ = 100`；
2.  服务端收到数据段时，向客户端发送带有 `SYN` 和 `ACK` 的数据段；
    1.  通过返回 `ACK = 101` 确认客户端数据段的初始序列号；
    2.  通过发送 `SEQ = 300` 通知客户端，服务端开始发送数据段的初始序列号；
3.  客户端向服务端发送带有 `ACK` 的数据段，确认服务端的初始序列号，其中包含 `ACK = 301`；

TCP 连接的双方会通过三次握手确定 TCP 连接的初始序列号、窗口大小以及最大数据段，这样通信双方就能利用连接中的初始序列号保证双方数据段的不重不漏、通过窗口大小控制流量并使用最大数据段避免 IP 协议对数据包的分片

![](https://pic4.zhimg.com/80/v2-07c065a0321f887ae69e269d8dda9f43_1440w.jpg)

1.  客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c).
2.  服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。
3.  为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。



## 四次挥手
![](https://pic3.zhimg.com/80/v2-629f51f6f535ebd7683f944707b21d1e_1440w.jpg)

1. 客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。 
2.  服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。 
3.  服务端发起自己的FIN段，ACK=K+1, Seq=L 
4.  客户端确认。ACK=L+1


**第一次分手：**主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入`FIN_WAIT_1`状态；这表示主机1没有数据要发送给主机2了；  
**第二次分手：**主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入`FIN_WAIT_2`状态；主机2告诉主机1，我“同意”你的关闭请求；  
**第三次分手：**主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入`LAST_ACK`状态；  
**第四次分手**：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入`TIME_WAIT`状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

## 常见问题

### 为什么`TIME_WAIT`状态还需要等`2MSL`后才能返回到`CLOSED`状态？

这是因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从`SYN_SEND`状态到`ESTABLISH`状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于`LAST_ACK`状态下的`Socket`可能会因为超时未收到`ACK`报文，而重发`FIN`报文，所以这个`TIME_WAIT`状态的作用就是用来重发可能丢失的`ACK`报文。

### TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态会产生什么问题
通信双方建立TCP连接后，主动关闭连接的一方就会进入`TIME_WAIT`状态，`TIME_WAIT`状态维持时间是两个MSL时间长度，也就是在1-4分钟，Windows操作系统就是4分钟。进入`TIME_WAIT`状态的一般情况下是客户端，一个`TIME_WAIT`状态的连接就占用了一个本地端口。一台机器上端口号数量的上限是65536个，如果在同一台机器上进行压力测试模拟上万的客户请求，并且循环与服务端进行短连接通信，那么这台机器将产生4000个左右的`TIME_WAIT` Socket，后续的短连接就会产生`address already in use : connect`的异常，如果使用`Nginx`作为方向代理也需要考虑`TIME_WAIT`状态，发现系统存在大量`TIME_WAIT`状态的连接，通过调整内核参数解决。