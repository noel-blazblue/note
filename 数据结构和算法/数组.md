### 买卖股票
> 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
> 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
> 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

- 记录一个最小数，每轮遍历都去判断当前数是否小于最小数，是则替换
- 记录一个`sum`，每轮遍历都去判断当前数减去最小数是否大于`sum`，是则替换

```js
var maxProfit = function(prices) {
  let min = Math.max()
  let sum = 0
  for (let i = 0; i < prices.length; i++) {
    if (prices[i] < min) {
      min = prices[i]
    } else if (prices[i] - min > sum) {
      sum = prices[i] - min
    }
  }
  return sum
};
```


>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。
>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**思路：**
设 tmp 为第 i-1 日买入与第 i 日卖出赚取的利润，即 tmp = prices[i] - prices[i - 1] ；
当该天利润为正 tmp > 0，则将利润加入总利润 profit；当利润为 00 或为负，则直接跳过；
遍历完成后，返回总利润 profit。

链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/best-time-to-buy-and-sell-stock-ii-zhuan-hua-fa-ji/



```js
var maxProfit = function(prices) {
  let acc = 0
  for (let i = 0; i < prices.length; i++) {
    let tmp = prices[i] - prices[i - 1]
    if (tmp > 0) {
      acc += tmp
    }
  }
  return acc
};
```


### 移动位置
>给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
- 记录一个变量`j`，以零为中点
- 每次遍历，如果当前数不是零，就把`nums[i]`和`nums[j]`进行替换，并且`j++`。
```js
var moveZeroes = function (nums) {
  let j = 0
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== 0) {
      [nums[i], nums[j]] = [nums[j], nums[i]]
      j++
    }
  }
  return nums
};
```

### 数组乱序
> 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。

交换原始数组，每次遍历，都把当前项和剩余数组长度产生的随机数的数组项替换。

```js
Solution.prototype.shuffle = function() {
  let arr = this.arr
  for (let i = 0; i < arr.length; i++) {
    let randomIndex = parseInt(Math.random() * (arr.length - i) + i)
    let tmp = arr[i]
    arr[i] = arr[randomIndex]
    arr[randomIndex] = tmp
  }
  return this.arr
};
```


### 数组中消失的数
给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。
链接：https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array

```
输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
```

思路：

找鸽子笼，由于数组中的每个数都在 1 ~ n 这个范围内，所以他们都可以安放在那个数对应的索引。

安放时，把这个数 + n，以作为标记。

由于安放数字有可能覆盖原来位置，所以在每次遍历时，把这个数取余n，就能获取到原来的数了。

最后遍历修改完成后的数组，发现有小于等于n的数，就是未标记，也就是消失的数，既把当前的索引i + 1记录到结果数组中。

代码：

```js
var findDisappearedNumbers = function(nums) {
  let n = nums.length
  for (let i = 0; i < n; i++) {
    let x = (nums[i] - 1) % n
    nums[x] += n
  }
  let res = []
  for (let i = 0; i < n; i++) {
    if (nums[i] <= n) {
      res.push(i + 1)
    }
  }
  return res
};
```


### 旋转数组的最小数字
https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

**输入：**[3,4,5,1,2]
**输出：**1

**思路：**
在一个递增排序的旋转数组中找到最小值，就是找到他的那个旋转点 x 。
![Picture1.png](https://pic.leetcode-cn.com/1599404042-JMvjtL-Picture1.png)

用二分法，`number[mid] > number[j] `, 证明现在在左排序数组，因此要 `j = m`.
`number[mid] < number[j] `,证明现在在右排序数组，因此要 `i = m + 1`.
如果相等，就 `j--`，以缩小范围。
最后，`i = j`，输出`number[i]`。

```js
var minArray = function(numbers) {
  let i = 0
  let j = numbers.length
  while (i < j) {
    let mid = Math.floor((i + j) / 2)
    if (numbers[mid] > numbers[j]) {
      i = mid + 1
    } else if (numbers[mid] < numbers[j]) {
      j = mid
    } else {
      j--
    }
  }
  return numbers[i]
};
```


## 矩阵

### 顺时针打印矩阵
https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
**输入：**matrix = \[\[1,2,3\],\[4,5,6\],\[7,8,9\]\]
**输出：**\[1,2,3,6,9,8,7,4,5\]

思路：
考虑设定矩阵的“左、上、右、下”四个边界，模拟以上矩阵遍历顺序。
![Picture1.png](https://pic.leetcode-cn.com/c6de3a1bc0f38820941dbcff0e17a49204eba91b967d4ccc0d5485e68a4fcc95-Picture1.png)
循环打印： “从左向右、从上向下、从右向左、从下向上” 四个方向循环，每个方向打印中做以下三件事 （各方向的具体信息见下表） ；
根据边界打印，即将元素按顺序添加至列表 res 尾部；
边界向内收缩 11 （代表已被打印）；
判断是否打印完毕（边界是否相遇），若打印完毕则跳出。

作者：jyd
链接：https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```js
var spiralOrder = function(matrix) {
  if (matrix.length === 0) return []
  let l = 0
  let r = matrix[0].length - 1
  let t = 0
  let b = matrix.length - 1
  let x = 0
  let res = []
  while (true) {
    for (let i = l; i <= r; i++) { res[x++] = matrix[t][i] }
    if (++t > b) break;
    for (let i = t; i <= b; i++) { res[x++] = matrix[i][r] }
    if (--r < l) break;
    for (let i = r; i >= l; i--) { res[x++] = matrix[b][i] }
    if (--b < t) break;
    for (let i = b; i >= t; i--) { res[x++] = matrix[i][l] }
    if (++l > r) break;
  }
  return res
};
```

