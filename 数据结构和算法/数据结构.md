## 线性表

**线性表**（Linear List）：就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。数组、链表、队列、栈 等就是线性表结构。

![çº¿æ§è¡¨](https://camo.githubusercontent.com/e1224436f682304379da61cf5ef4fd2c00626aaf/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d636665393938626365303866616534332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)



### 数组

#### 特点

- **数组是用一组连续的内存空间来存储的**。
  所以数组支持 **随机访问**，根据下标随机访问的时间复杂度为 O(1)。
- **低效的插入和删除**。
  数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效，因为底层通常是要进行大量的数据搬移来保持数据的连续性。
  插入与删除的时间复杂度如下：
  插入：从最好 O(1) ，最坏 O(n) ，平均 O(n)
  删除：从最好 O(1) ，最坏 O(n) ，平均 O(n)



### 栈

#### ![æ ](https://camo.githubusercontent.com/7c600a629c9afdc295195dfaeb31b9baa6dca542/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d363131303632336634306331616438362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

#### 定义

1. 后进者先出，先进者后出，简称 **后进先出**（LIFO），这就是典型的`栈`结构。
2. 新添加的或待删除的元素都保存在栈的末尾，称作`栈顶`，另一端就叫`栈底`。
3. 在栈里，新元素都靠近栈顶，旧元素都接近栈底。
4. 从栈的操作特性来看，是一种 `操作受限`的线性表，**只允许在一端插入和删除数据。**
5. 不包含任何元素的栈称为`空栈`。

栈也被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈。



#### 实现

栈的方法：

```javascript
function Stack() {
  this.items = [];
  // 添加新元素到栈顶
  this.push = function(element) {
    this.items.push(element);
  };
  // 移除栈顶元素，同时返回被移除的元素
  this.pop = function() {
    return this.items.pop();
  };
  // 查看栈顶元素
  this.peek = function() {
    return this.items[this.items.length - 1];
  };
  // 判断是否为空栈
  this.isEmpty = function() {
    return this.items.length === 0;
  };
  // 清空栈
  this.clear = function() {
    this.items = [];
  };
  // 查询栈的长度
  this.size = function() {
    return this.items.length;
  };
  // 打印栈里的元素
  this.print = function() {
    console.log(this.items.toString());
  };
}
测试：
// 创建Stack实例
var stack = new Stack();
console.log(stack.isEmpty()); // true
stack.push(5); // undefined
stack.push(8); // undefined
console.log(stack.peek()); // 8
stack.push(11); // undefined
console.log(stack.size()); // 3
console.log(stack.isEmpty()); // false
stack.push(15); // undefined
stack.pop(); // 15
console.log(stack.size()); // 3
stack.print(); // 5,8,11
stack.clear(); // undefined
console.log(stack.size()); // 0
```



### 队列

![éå](https://camo.githubusercontent.com/b5fad7f5306a1a0203fa27f125609234afbc9364/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d653136626230653833303563616136622e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

#### 定义

- 队列是遵循 FIFO（First In First Out，**先进先出**）原则的一组有序的项。
- 队列在尾部添加新元素，并从顶部移除元素。
- 最新添加的元素必须排在队列的末尾。
- 队列只有 入队 push() 和出队 pop()。

#### 实现

```JavaScript
// Queue类
function Queue() {
	this.items = [];
	// 向队列尾部添加元素
	this.enqueue = function(element) {
		this.items.push(element);
	};
	// 移除队列的第一个元素，并返回被移除的元素
	this.dequeue = function() {
		return this.items.shift();
	};
	// 返回队列的第一个元素
	this.front = function() {
		return this.items[0];
	};
	// 判断是否为空队列
	this.isEmpty = function() {
		return this.items.length === 0;
	};
	// 获取队列的长度
	this.size = function() {
		return this.items.length;
	};
	// 清空队列
	this.clear = function() {
		this.items = [];
	};
	// 打印队列里的元素
	this.print = function() {
		console.log(this.items.toString());
	};
}
//测试：
// 创建Queue实例
var queue = new Queue();
console.log(queue.isEmpty()); // true
queue.enqueue('John'); // undefined
queue.enqueue('Jack'); // undefined
queue.enqueue('Camila'); // undefined
queue.print(); // "John,Jack,Camila"
console.log(queue.size()); // 3
console.log(queue.isEmpty()); // false
queue.dequeue(); // "John"
queue.dequeue(); // "Jack"
queue.print(); // "Camila"
queue.clear(); // undefined
console.log(queue.size()); // 0
```



### 优先队列

#### 定义

优先队列中元素的添加和移除是依赖`优先级`的。

**优先队列分为两类**

- 最小优先队列
  - 把优先级的值最小的元素被放置到队列的最前面（代表最高的优先级）。
- 最大优先队列
  - 把优先级值最大的元素放置在队列的最前面。

#### **实现**

```JavaScript
// 优先队列添加元素，要根据优先级判断在队列中的插入顺序
function enqueue (element, priority) {
  var queueElement = {
    element: element,
    priority: priority
  };
  if (this.isEmpty()) {
    this.items.push(queueElement);
  } else {
    var added = false;
    for (var i = 0; i < this.size(); i++) {
      if (queueElement.priority < this.items[i].priority) {
        this.items.splice(i, 0, queueElement);
        added = true;
        break ;
      }
    }
    if (!added) {
      this.items.push(queueElement);
    }
  }
}
// 打印队列里的元素
function print () {
  var strArr = [];
  strArr = this.items.map(function (item) {
    return `${item.element}->${item.priority}`;
  });
  console.log(strArr.toString());
}
```



### 循环队列

#### 定义

循环队列，顾名思义，它长得像一个环。把它想像成一个圆的钟就对了。

关键是：确定好队空和队满的判定条件。

#### 实现

```javascript
// 实现击鼓传花
function hotPotato (nameList, num) {
  var queue = new Queue();
  for (var i = 0; i < nameList.length; i++) {
    queue.enqueue(nameList[i]);
  }
  var eliminated = '';
  while (queue.size() > 1) {
    // 循环 num 次，队首出来去到队尾
    for (var i = 0; i < num; i++) {
      queue.enqueue(queue.dequeue());
    }
    // 循环 num 次过后，移除当前队首的元素
    eliminated = queue.dequeue();
    console.log(`${eliminated} 在击鼓传花中被淘汰！`);
  }
  // 最后只剩一个元素
  return queue.dequeue();
}
// 测试
var nameList = ["John", "Jack", "Camila", "Ingrid", "Carl"];
var winner = hotPotato(nameList, 10);
console.log(`最后的胜利者是：${winner}`);
```



#### 



### 单链表

#### 定义

- 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的，它是通过 **指针** 将 **零散的内存块** 串连起来的。
- 每个元素由一个存储元素本身的 **节点** 和一个指向下一个元素的 **引用**（也称指针或链接）组成。

![img](https://camo.githubusercontent.com/8e147408e628dcb33ce418389f8a93fbd74969ff/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d613463623739336139323736643335382e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)



#### 特点

- **链表是通过指针将零散的内存块串连起来的**。
  所以链表不支持 **随机访问**，如果要找特定的项，只能从头开始遍历，直到找到某个项。
  所以访问的时间复杂度为 O(n)。

- **高效的插入和删除**。

  链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的，只需要考虑相邻结点的指针改变。
  所以，在链表中插入和删除一个数据是非常快速的，时间复杂度为 O(1)。



#### 实现

```javascript
// 单链表
function SinglyLinkedList() {
	// 节点
	function Node(element) {
		this.element = element; // 当前节点的元素
		this.next = null; // 下一个节点指针
	}

	var length = 0; // 链表的长度
	var head = null; // 链表的头部节点

	// 向链表尾部添加一个新的节点
	this.append = function(element) {
		var node = new Node(element);
		var currentNode = head;

		// 判断是否为空链表
		if (head === null) {
			// 是空链表，就把当前节点作为头部节点
			head = node;
		} else {
			// 从 head 开始一直找到最后一个 node
			while (currentNode.next) {
				// 后面还有 node
				currentNode = currentNode.next;
			}
			// 把当前节点的 next 指针 指向 新的节点
			currentNode.next = node;
		}
		// 链表的长度加 1
		length++;
	};

	// 向链表特定位置插入一个新节点
	this.insert = function(position, element) {
		if (position < 0 || position > length) {
			// 越界
			return false;
		} else {
			var node = new Node(element);
			var index = 0;
			var currentNode = head;
			var previousNode;

			// 在最前插入节点
			if (position === 0) {
				node.next = currentNode;
				head = node;
			} else {
				// 循环找到位置
				while (index < position) {
					index++;
					previousNode = currentNode;
					currentNode = currentNode.next;
				}
				// 把前一个节点的指针指向新节点，新节点的指针指向当前节点，保持连接性
				previousNode.next = node;
				node.next = currentNode;
			}

			length++;

			return true;
		}
	};

	// 从链表的特定位置移除一项
	this.removeAt = function(position) {
		if ((position < 0 && position >= length) || length === 0) {
			// 越界
			return false;
		} else {
			var currentNode = head;
			var index = 0;
			var previousNode;

			if (position === 0) {
				head = currentNode.next;
			} else {
				// 循环找到位置
				while (index < position) {
					index++;
					previousNode = currentNode;
					currentNode = currentNode.next;
				}
				// 把当前节点的 next 指针 指向 当前节点的 next 指针，即是 删除了当前节点
				previousNode.next = currentNode.next;
			}

			length--;

			return true;
		}
	};

	// 从链表中移除指定项
	this.remove = function(element) {
		var index = this.indexOf(element);
		return this.removeAt(index);
	};

	// 返回元素在链表的索引，如果链表中没有该元素则返回 -1
	this.indexOf = function(element) {
		var currentNode = head;
		var index = 0;

		while (currentNode) {
			if (currentNode.element === element) {
				return index;
			}

			index++;
			currentNode = currentNode.next;
		}

		return -1;
	};

	// 如果链表中不包含任何元素，返回 true，如果链表长度大于 0，返回 false
	this.isEmpty = function() {
		return length === 0;
	};

	// 返回链表包含的元素个数，与数组的 length 属性类似
	this.size = function() {
		return length;
	};

	// 获取链表头部元素
	this.getHead = function() {
		return head.element;
	};

	// 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值
	this.toString = function() {
		var currentNode = head;
		var string = '';

		while (currentNode) {
			string += ',' + currentNode.element;
			currentNode = currentNode.next;
		}

		return string.slice(1);
	};

	// 打印链表数据
	this.print = function() {
		console.log(this.toString());
	};

	// 获取整个链表
	this.list = function() {
		console.log('head: ', head);
		return head;
	};
}
```

